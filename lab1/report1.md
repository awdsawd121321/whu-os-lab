# 《操作系统实践A》实验报告

| 实验名称 | **实验一：RISC-V 引导与裸机启动** |
| :--- | :--- |
| 学院 | 计算机学院 |
| 专业 | 计算机科学与技术 |
| 班级 | 计算机类15班 |
| 学号 | 2023305231024 |
| 姓名 | 蒋志豪 |
| 日期 | 2025/9/17 |

---

## 摘要

本次实验的核心目标是理解并实现一个最小化的操作系统内核引导过程。通过学习 RISC-V 架构的启动规范，我们从零开始编写了启动汇编代码 (`entry.S`) 和链接器脚本 (`kernel.ld`)。实验内容涵盖了设置初始栈指针，并从汇编代码安全地跳转到 C 语言入口函数 `main`。最终，通过在 QEMU 模拟器中成功利用 UART 串口输出信息，验证了裸机启动流程的正确性，为后续更复杂的内核功能开发奠定了坚实的基础。

**关键词**: `操作系统`, `RISC-V`, `裸机启动`, `引导加载`, `链接脚本`, `汇编`, `QEMU`

---

## 1. 实验环境

* **软件平台**: 
    * 虚拟机软件: VMware Workstation 17 Pro
    * 虚拟机操作系统: Ubuntu 22.04 LTS
* **开发工具**:
    * RISC-V 工具链: `riscv64-unknown-elf-gcc` (版本: 13.2.0 或更高)
    * 模拟器: QEMU `qemu-system-riscv64` (版本: 6.2.0 或更高)
    * 代码编辑器: Visual Studio Code (通过 Remote-SSH 连接)
    * 构建工具: GNU Make
    * 版本控制: Git

---

## 2. 系统设计

### 2.1 启动流程设计
为了实现一个最精简但完整的操作系统启动，我设计的启动流程如下：
1.  **QEMU 加载内核**: QEMU 模拟器将编译好的 `kernel.elf` 可执行文件加载到物理内存的起始地址 `0x80000000`。
2.  **设置入口点**: CPU 从 `0x80000000` 开始执行第一条指令。通过链接脚本，我们确保该地址对应的是 `entry.S` 文件中的 `_start` 标签。
3.  **准备C环境 - 设置栈指针**: C 语言函数的运行依赖于栈。因此，启动代码的第一步就是初始化 `sp` (Stack Pointer) 寄存器，使其指向一块我们预先分配好的、大小为 4KB 的内存区域的顶部，为即将到来的 C 函数调用做好准备。
4.  **跳转到 C 入口**: C 环境准备就绪后，使用 `call main` 指令，将程序控制权从汇编代码转移到 C 语言的 `main` 函数。
5.  **执行 C 代码**: 在 `main` 函数中，调用一系列底层函数，通过 UART 串口输出字符，以验证整个流程的正确性。
6.  **系统停机**: 为防止 CPU 在 `main` 函数执行完毕后执行未知的指令 ("跑飞")，在 `main` 函数的末尾加入了一个无限循环 `while(1);`，使系统在完成任务后安全地挂起。

### 2.2 内存布局设计
我通过编写链接脚本 `kernel.ld`，对内核的内存布局进行了精确控制：

* **起始地址 (`BASE_ADDRESS`)**: 设置为 `0x80000000`，这是 QEMU `virt` 机器的 DRAM 起始地址。
* **段组织**:
    * `.text` 段：存放所有可执行代码。我将 `entry.S` 中的 `.text.entry` 段放在最前面，确保 `_start` 位于 `0x80000000`。
    * `.rodata`, `.data`, `.bss` 段：这些段在本阶段虽然未显式使用复杂数据，但链接脚本已为它们预留了标准位置。
    * **内核栈**: 在所有数据段之后，通过 `. = ALIGN(16);` 进行对齐，然后分配 4096 字节空间，并定义 `stack_top` 符号供汇编代码使用。

**核心代码 (kernel.ld):**
```ld
/* * 链接脚本的核心部分，定义了入口点、基地址和内存段布局。
*/
OUTPUT_ARCH(riscv)
ENTRY(_start)

SECTIONS
{
    . = 0x80000000;
    
    .text : {
        *(.text.entry) /* 确保启动代码在最前面 */
        *(.text .text.*)
    }
    
    /* 其他标准段定义 */
    .rodata : { *(.rodata .rodata.*) }
    .data : { *(.data .data.*) }
    .bss : { *(.bss .bss.*) }

    /* 栈空间定义 */
    . = ALIGN(16);
    stack_bottom = .;
    . += 4096; /* 分配 4KB 栈空间 */
    stack_top = .;
}
```
## 3. 实验过程与实现
### 3.1 核心代码实现
#### 3.1.1 启动汇编 (kernel/entry.S)
这是内核的第一段代码，负责设置最基础的执行环境。
```ld
.section .text.entry
.globl _start
_start:
    # 设置栈指针 sp
    # stack_top 符号由链接脚本 kernel.ld 定义
    la sp, stack_top

    # 跳转到 C 语言的 main 函数
    call main

如果 main 函数返回 (理论上不应该), 进入死循环
loop:
    j loop
```
#### 3.1.2 UART 驱动 (kernel/uart.c)
一个极简的串口输出实现，通过内存映射I/O直接操作硬件寄存器。
```C
复制代码
// 定义 UART 硬件寄存器地址
#define UART_THR (volatile unsigned char *)0x10000000L

void uart_putc(char c) 
{
    // 向发送保持寄存器写入一个字符
    *UART_THR = c;
}
```
#### 3.1.3 C 入口函数 (kernel/main.c)
C 代码的入口点，负责调用 UART 驱动打印字符串并挂起系统。
```C
复制代码
// 声明外部函数
void uart_putc(char c)
;

void main() 
{
    char *s = "Hello OS\n"
;
    while
 (*s) {
        uart_putc(*s++);
    }

    // 进入死循环, 防止程序跑飞
    while (1
);
}
```
### 3.2 遇到的问题与解决方案
**问题**: QEMU 启动后没有任何输出，直接退出。
**分析**: 这通常意味着 CPU 执行了非法指令或访问了非法内存。最可能的原因是栈未正确设置，导致 call main 指令执行失败，或者 main
 函数返回后程序跑飞。
**解决方案**: 仔细检查 kernel.ld 中 stack_top 的定义和 entry.S 中 la sp, stack_top 指令。最终发现是链接脚本中的对齐值写错了，导致 stack_top 地址无效。修正对齐后问题解决。

## 4. 测试与验证
### 4.1 测试方案
**测试目的**: 验证整个引导流程是否正确，内核能否成功运行 C 代码并与外部设备（串口）交互。
**测试步骤**:
```
1. 编写 Makefile，包含编译、链接、运行 QEMU 的命令。
2. 在终端执行 make qemu。
3. 观察 QEMU 的输出终端。
```
### 4.2 测试结果
执行 make qemu 后，终端显示如下：
```Bash
复制代码
--- Starting QEMU ---
Hello OS
--- QEMU finished ---
```

**结果分析**:
终端成功打印出预期的 "Hello OS" 字符串，表明从 QEMU 加载、汇编代码执行、栈设置、C 函数调用到硬件 I/O 操作的整个引导链条全部工作正常。实验达到预期目标。

5. 思考题与讨论
### 5.1 启动栈的设计
1. **你如何确定栈的大小？考虑哪些因素？**
栈的大小需要根据内核代码的复杂度来预估。在本实验这种极简的裸机环境中，我们没有复杂的函数调用，也没有递归，因此分配一个相对较小的栈空间（例如 4KB）是足够的。如果是在更复杂的系统中，栈的大小需要考虑以下因素:
**函数调用深度**：每调用一个函数，都会将返回地址和局部变量压入栈，深度越深，所需空间越大。
**中断处理**：中断发生时，CPU状态和返回地址会被压栈。
**局部变量**：大型的局部变量数组会占用大量栈空间。
**可变参数**：如 printf 等函数会使用可变参数，这些参数在栈上组织。
2. **如果栈太小会发生什么？如何检测栈溢出？**
如果栈空间太小，会发生栈溢出（Stack Overflow）。当程序持续向栈中压入数据（如深度递归或大型局部变量）超过其预留空间时，就会覆盖栈底之外的内存区域，可能导致数据损坏或覆盖到其他段（如 .bss 或 .text
），进而引发不可预知的程序行为或崩溃。
在裸机环境中，检测栈溢出可以采用以下方法：
**栈警戒区（Stack Canary）**：在栈底放置一个特殊的值，定期检查该值是否被意外修改。
**硬件辅助**：某些架构提供了硬件机制来检测栈溢出。
**软件监控**：在启动时将栈空间初始化为一个特殊的值（如 0xdeadbeef），在程序运行时定期检查栈指针是否超出了预设范围。
### 5.2 BSS 段清零
1. **写一个全局变量，不清零BSS会有什么现象？**
BSS（Block Started by Symbol）段用于存放未初始化的全局变量和静态变量。C语言标准规定这些变量的初始值必须为零。如果在裸机环境中，启动汇编代码没有执行清零操作，那么BSS段中的变量值将是内存中的
随机垃圾数据。这会导致程序行为不可预测，例如一个本应从0开始计数的全局计数器可能会从一个随机的大值开始。
2. **哪些情况下可以省略BSS清零？**
在大多数通用的操作系统和嵌入式系统中，BSS清零是一个标准且必须的步骤。然而，在某些极端简化的或特定用途的裸机程序中，如果开发者能确保所有未初始化的全局/静态变量都未被使用，或者其初始值无关紧要，则理论上可以省略此步骤。但这是一种非常不安全的做法，不推荐在正式项目中采用。
### 5.3 与xv6的对比
1. **你的实现比xv6简化了哪些部分？**
我的最小系统实现相比 xv6 简化了许多关键部分:
**内存管理**：我的实现没有物理内存分配器和分页机制，而 xv6 实现了复杂的 Sv39 分页机制来管理虚拟和物理地址空间。
**多核支持**：我的代码只针对单核环境，而 xv6 支持多核。
**设备驱动**：我的 UART 驱动只是一个最简化的、无缓冲的单字符输出函数，而 xv6 的 uart.c 驱动则包含更完整的功能和中断处理。
**C库和文件系统**：我的系统没有任何标准库函数或文件系统功能，而 xv6 包含了精简的C库和简化的文件系统。
2. **这些简化在什么情况下会成为问题？**
这些简化使得我的系统无法用于任何复杂应用，因为它们会带来以下问题:
**内存分配**：无法动态分配内存，限制了程序运行时的数据结构大小。
**地址隔离**：没有虚拟内存，用户程序无法与内核隔离，存在安全隐患。
**多任务处理**：不支持多核并行和进程切换，无法同时运行多个任务。
**调试和错误处理**：简化的输出系统在发生复杂错误时难以提供足够的诊断信息。
### 5.4 错误处理
1. **如果 UART 初始化失败，系统应该如何处理？**
在裸机环境中，如果 UART 初始化失败，系统很难进行“优雅”的错误处理，因为这是唯一的输出通道。在更复杂的系统中，可以考虑以下策略:
**硬件灯闪烁**：通过操作主板上的LED灯，通过不同的闪烁模式来表示错误代码。
**蜂鸣器警告**：通过发出不同频率或次数的蜂鸣声来提示错误。
**进入安全模式**：如果初始化失败，程序可以进入一个无限循环，或尝试重启，等待开发者介入调试。
2. **如何设计一个最小的错误显示机制？**
一个最小的错误显示机制可以基于一个简单的整数错误码。例如，在 
main 函数的开头，如果检测到错误，可以跳到一个特定的汇编代码段，该代码段将一个预定义的错误码（例如，0xdead）写入一个已知的内存地址（如 0x10000004），然后进入死循环。开发者在 QEMU 退出后，可以通过检查内存转储来判断错误原因。